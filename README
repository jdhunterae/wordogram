# Wordogram — Game & Puzzle Mechanics (Design Doc v1.1)

**Goal:** Ship a small, legible word‑puzzle that's easy to reason about and easy to port to Flutter. This doc defines the UX, data, and rules so the web prototype can be refactored cleanly.

---

## 1) Core Concept (revised)

A letter-picross built from a hidden phrase. Each row and column shows the letters that appear in that line (optionally with counts). Punctuation auto-fills and is not part of hints.

### Feedback model (no row/column glyphs)

- **Hint letters** (in the row/column lists) are muted only when all instances of that letter in that line are correctly placed. Otherwise they render normally.
- **Letter tiles** communicate state themselves:
  - **Locked** — confirmed correct (via Auto-check, Check, or Hint); input disabled; distinct locked style.
  - **Editable** — user can type; no verdict yet (when Auto-check is off) or until validated (when on).
  - **Wrong** — red border when the letter is incorrect for that cell; the border clears when the letter is removed or corrected.
  - **Empty cells are never marked.**

### Primary loop

- Scan row/column hint letters.
- Type letters into the grid.
- Watch hint letters mute as you complete letters in a line; tiles lock via Auto-check or Check.
- Optionally use Hint to reveal and lock a letter.

> Note: We're not using the "chip states" concept (todo/progress/done) or any ✓/✕/! line indicators. Progress is expressed solely by muting hint letters when fully satisfied and by tile-level feedback (locked / editable / wrong).

---

## 2) Data Model (v1.0)

```json
{
  "id": "string",
  "rows": 0,
  "cols": 0,
  "solution": ["..."], // letters + spaces only; each string length == cols
  "overlay": [
    // auto-filled, non-editable (punctuation etc.)
    { "row": 0, "col": 0, "ch": "," }
  ],
  "meta": { "phrase": "optional", "author": "optional", "date": "optional" },
  "version": "1.0"
}
```

Derived at runtime (not stored):

- `RowTargets[r] = Map<char, count>` from `solution[r]` letters only
- `ColTargets[c] = Map<char, count>` from column letters only
- `OverlaySet = Set(index)` from `overlay`

---

## 3) Grid & Cell Types

### Overlay cell

- Fixed punctuation from `overlay[]`. Non-interactive. Excluded from counts/validation. Always rendered.

### Tile cell (non-overlay)

A single interactive cell that may target either a letter or a space in the solution. Users can type in any non-overlay tile.

- **Editable — empty**: no character typed.
- **Editable — typed**: user has entered a letter (A–Z). Still editable until validated/locked.
- **Locked — correct letter**: confirmed match to the solution (via Auto-check, Check, or Hint). Input disabled; distinct locked style. Hint-placed letters use a distinct hint color.
- **Locked — space**: solution is a space. This tile stays editable/empty and is not marked on its own. It locks (muted "gutter" style) only when its row or column is complete or after a Check that completes the line.
- **Marked — wrong**: red border when the typed letter is incorrect for that cell. Clears when the letter is removed or corrected. Empty tiles are never marked.

### Typing rules

- Accept only letters A–Z; input uppercased. Backspace clears the cell.
- For a tile whose solution is a space: typing any letter is wrong whenever validation is active (Auto-check ON, or during a Check). Leaving it empty is neutral and never marked.

### Typing feedback (controlled by Auto-check)

- **Auto-check OFF →** no per-keystroke validation; tiles are validated/locked only on Check.
- **Auto-check ON →** immediate validation: correct letters lock as you type; wrong letters show a red border that clears on erase. Space targets never lock on type; they lock only via line completion or Check.

---

## 4) Hints UI

### 4.1 Layout (no wrapping)

- **Row hints**: render as a single horizontal line to the left of each grid row.
  - Must not wrap to a second visual line inside the row’s hint tile.
  - If content exceeds width, horizontally scroll that hint area (no wrap).
- **Column hints**: render as a single vertical stack above each grid column.
  - Must not wrap into a second side-by-side column inside the column’s hint tile.
  - If content exceeds height, vertically scroll that hint area (no wrap).
- Hint tile dimensions are tied to the grid cell size; overflow is managed by scrollbars or auto-scroll behavior (no overflow into neighbors, no wrapping).

### 4.2 What hints show (letters only; optional counts)

There are **no chips and no line glyphs (no ✓/✕/!)**. Hints are just letters (A–Z), optionally with a small superscript number.

- **Counts disabled**
  - **Normal**: show each distinct letter that appears in that row/column.
  - **Completed**: mute a letter when all instances of that letter in that line have been locked (i.e., confirmed correct in the grid). No number is shown.
- **Counts enabled**
  - **Normal**: show each distinct letter with a `sup` of how many are left to be found in that line.
    - `left(letter) = targetCount(letter in line) − lockedCount(letter in line)`
    - `lockedCount` counts only tiles that are locked-correct (via Auto-check, Check, or Hint). Typed-but-not-validated letters do not reduce `left`.
  - **Completed**: mute the letter and show `sup 0` when all instances are locked.

> A letter is muted only when its lockedCount meets the target (all instances placed). Merely typing a letter (not yet validated/locked) never mutes it or reduces left.

### 4.3 When hint states update

Hint visuals update only on validation events:

- **Auto-check ON**: immediately after a keystroke locks a correct letter, or when a typed letter is erased (which may unmark a wrong border but does not unlock already-locked tiles).
- **Check button**: after processing (locking correct tiles and marking wrong ones).
- **Hint button**: immediately after a hint fills and locks a letter.
- **Clear / Reset**: recompute from scratch (everything returns to normal/unmuted with full `left` counts).

### 4.4 Calculation details & edge cases

- Target counts per line are derived from `solution` letters only (ignore spaces and overlay).
- Locked counts per line count only locked-correct tiles that match `solution` at that position (includes hint-placed letters).
- If a user over-types extra instances of a letter in wrong positions, those are not locked and do not reduce `left`.
- Muting is per-line: a letter may be muted in one row/column and still normal in another.

---

## 5) Mechanics & Algorithms

### 5.1 Targets & locked counts

For a line `L` (row or column):

- `Target[L][ch]` = number of times letter ch appears in solution for that line (letters only; ignore spaces/overlay).
- `Locked[L][ch]` = number of locked-correct tiles in that line whose letter is ch (includes letters locked by Auto-check, Check, or Hint; never counts typed-but-unvalidated letters).
- `Left[L][ch] = max( Target[L][ch] − Locked[L][ch], 0 )`.

Hint visuals depend only on `Locked` (**not on typed letters**):

- **Counts OFF**: a hint letter is **muted** if `Left[L][ch] == 0`; otherwise normal.
- **Counts ON**: show `ch` with `sup Left[L][ch]`; the letter is muted when `Left[L][ch] == 0` (still display `sup 0`).

Hint areas update only on validation events (Auto-check locks a letter, Check runs, Hint places a letter, Clear/Reset).

### 5.2 Validation model

#### Auto-check OFF (manual)

- Typing does not validate.
- On Check:
  - If a typed letter equals `solution[r][c]` → lock that tile.
  - If a typed letter does not equal `solution[r][c]` → mark red (incorrect).
  - Empty tiles are not marked (no green/red).

#### Auto-check ON (immediate)

- On each keystroke in a non-locked, non-overlay tile:
  - If empty → clear any red border.
  - If typed letter == `solution[r][c]` → **lock** immediately.
  - Else → mark red; removing the letter clears the red border.
- Locked tiles ignore further input.

**Space targets**: If `solution[r][c]` is a space, any typed letter is wrong when validation is active (red border in Auto-check; marked red on Check). Leaving it empty is neutral and never marked.

### 5.3 Locking rules

A tile becomes locked when:

- it’s validated correct by **Auto-check** or **Check**, or
- it’s filled by Hint (uses a distinct hint text color).

Locked tiles are read-only; overlay punctuation is always locked.

### 5.4 Hint button

- Consumes one hint.
- Chooses a random unsolved **letter tile** and inserts the correct letter.
- The letter is **locked** immediately and styled with a distinct **hint color**.

### 5.5 Line completion locking (spaces)

- A **row** is _complete_ when every letter tile in that row is locked-correct (ignore spaces/overlay). When complete, **lock all space tiles** in that row with a muted "gutter" style.
- A **column** is _complete_ when every letter tile in that column is locked-correct. When complete, **lock all space tiles** in that column.

---

## 6) Controls & Options

- **Check**: runs full validation per §5.3 (according to current Auto‑check setting). Locks only correct letters; marks incorrect letters red; leaves empty cells unmarked.
- **Clear**: clears all letter inputs and cell markings; overlay remains.
- **Hint**: see §5.4.

### 6.1 Toggles (config)

- **Show letter counts** _(default: OFF)_ — shows counts as superscripts on hint letters (value = `Left` remaining).
- **Auto‑check** _(default: OFF)_ — toggles the per‑keystroke validation model in §5.3.

---

## 7) Visual & Accessibility

- Cell size = CSS var `--cell-size` (default 56px); hint tiles computed from it.
- Minimum touch targets ≥ 48dp; keyboard nav with arrows; focus ring visible.
- High‑contrast; hint letters use muted styling + opacity; tile states rely on border/lock styles (not color alone).

---

## 8) Persistence

- Grid state key: `wordogram:<puzzleId>` → `{ values[], hintsLeft }`.
- **Session statistics key**: `wordogram:<puzzleId>:stats` →

```json
{
  "hintsUsed": 0,
  "incorrectLetters": 0, // total wrong entries typed or revealed by Check
  "attempts": 0, // Auto‑check OFF: times Check was clicked; Auto‑check ON: incorrectLetters + 1 (on completion)
  "usedAutoCheck": false,
  "usedLetterCounts": false
}
```

- Stats update rules:
  - Increment `hintsUsed` on each Hint.
  - Increment `incorrectLetters` for each cell marked wrong during a Check, or each invalid keystroke in Auto‑check mode.
  - Increment `attempts` on each Check (Auto‑check OFF). In Auto‑check ON, set `attempts = incorrectLetters + 1` when the puzzle is completed.

---

## 9) Builder (phrase → puzzle)

- Split on **whitespace only**; keep in‑chunk punctuation.
- Choose width in `[minWidth..maxWidth]` to minimize lines; tie‑break smaller width.
- Greedy shift for overlaps; optional pins `{row, rawIndex, targetCol}`.
- Output matches Data Model v1.0.

---

## 10) Acceptance Criteria

1. **Overlay correctness**: punctuation auto‑fills in correct cells; excluded from counts.
2. **Hint areas**: letters mute only when all instances are **locked**; with counts enabled, superscript shows **Left** (0 when complete). Updates only on validation requests.
3. **Validation behavior**:

   - Auto‑check OFF: **Check** locks only correct letters; marks only incorrect letters; leaves empty cells unmarked.
   - Auto‑check ON: keystrokes immediately lock correct letters or mark red on mismatch; red clears when the input is emptied.

4. **Hint button**: inserts a correct letter, **locks** it, and applies distinct **hint color**.
5. **Row/Column completion**: when a line is complete, its **space cells lock** with a muted gutter style.
6. **Layout**: row hints are horizontal lists; column hints are vertical lists; tiles are sized to `--cell-size` and never overflow neighbors.
7. **Statistics** persist and match the rules in §8.

---

## 11) Implementation Plan (Refactor)

### Phase A — logic split

- `logic/targets.js` → build RowTargets/ColTargets
- `logic/evaluate.js` → `evaluateLine`, `validateCell`, `checkPuzzle`
- `logic/hints.js` → derive `Locked`/`Left` per line + muting

### Phase B — UI split

- `ui/grid.js` → renderGrid, input handlers, locking helpers
- `ui/hints.js` → render row/column hint tiles with orientation
- `ui/stats.js` → track & persist session stats
- `state/persist.js` → load/save
- `app.js` → glue + controls

### Phase C — styling

- Define `--cell-size`; set hint tile dims from it
- Hint letter sizes: 11px text, 9px superscripts; tiles min‑height 32–36px

---

## 12) Open Questions

- Smart hint selection (target conflicted lines) vs purely random?
- Optional keyboard shortcuts (H for hint, Enter for check)?

---

## 13) Pseudocode Snippets

**evaluateLine(lineIndex, axis: 'row'|'col', grid, targets, options)**

```
T = targets[axis][lineIndex]  // Map<char, targetCount>
L = countLockedByLine(axis, lineIndex) // Map<char, LockedCount>
Left[ch] = max(T[ch] - (L[ch] || 0), 0)
// UI rules:
// counts OFF -> mute letter if Left[ch]==0
// counts ON -> show ch with sup Left[ch]; mute when Left[ch]==0
```

**validateCell(r,c, grid, solution, options, mode)**

```
if mode === 'auto':
  if empty: clear red; return
  if letter == solution[r][c]: lock cell; return
  else: mark red; stats.incorrectLetters++
else: // manual; only respond on Check
  do nothing here
```

**checkPuzzle(grid, solution, options)**

```
wrong = 0
for each letter cell (r,c):
  if typed == solution[r][c]: lock cell
  else if typed != '' : mark red; wrong++
// empty cells untouched
stats.attempts++
return wrong
```

**onHint()**

```
place a correct letter in a random unsolved cell
lock it
stats.hintsUsed++
```

**onLineCompleted(lineIndex, axis)**

```
if all chips are 'done' AND every letter cell correct:
  lock all space cells in that line with gutter style
```

---

## 14) Done = Ready to Code

When the above is signed off, refactor the web prototype per §§11–13, then mirror the logic in Flutter with unit tests for chip states, validation modes, and stats updates.
